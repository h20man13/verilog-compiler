\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{classAdd}{Add}} }{\pageref{classAdd}}{}
\item\contentsline{section}{\mbox{\hyperlink{classAssignment}{Assignment}} \\*The assignment template is used to create assignments in verilog }{\pageref{classAssignment}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBAnd}{BAnd}} \\*The bitwise and class is used to perform bitwise and operation }{\pageref{classBAnd}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBinary}{Binary}} }{\pageref{classBinary}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBlocking}{Blocking}} \\*The assignment template is used to create assignments in verilog }{\pageref{classBlocking}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBNeg}{BNeg}} \\*The \mbox{\hyperlink{classBNeg}{BNeg}} performs a bitwise negation in verilog or a $\sim$ }{\pageref{classBNeg}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBoolean}{Boolean}} }{\pageref{classBoolean}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBOr}{BOr}} \\*The Bitwise or operation is used to perform a bitwise or operation }{\pageref{classBOr}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBXNor}{BXNor}} \\*The binary Xnor operation performs a bitwise or with a bitwise negation at the end }{\pageref{classBXNor}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBXor}{BXor}} \\*The binary Xnor operation performs a bitwise or with a bitwise negation at the end }{\pageref{classBXor}}{}
\item\contentsline{section}{\mbox{\hyperlink{classByte}{Byte}} }{\pageref{classByte}}{}
\item\contentsline{section}{\mbox{\hyperlink{classCase}{Case}} }{\pageref{classCase}}{}
\item\contentsline{section}{\mbox{\hyperlink{classCaseItem}{Case\+Item}} }{\pageref{classCaseItem}}{}
\item\contentsline{section}{\mbox{\hyperlink{classCaseX}{CaseX}} }{\pageref{classCaseX}}{}
\item\contentsline{section}{\mbox{\hyperlink{classCaseZ}{CaseZ}} }{\pageref{classCaseZ}}{}
\item\contentsline{section}{\mbox{\hyperlink{classConcatenation}{Concatenation}} \\*The concatenation ast node class is used to simulate concatenation nodes in verilog (Ex\+: \{x, y, z\} where z y and z are wires or registers }{\pageref{classConcatenation}}{}
\item\contentsline{section}{\mbox{\hyperlink{classConstantExpression}{Constant\+Expression}} \\*The constant expression Ast node class is used to check constant expressions }{\pageref{classConstantExpression}}{}
\item\contentsline{section}{\mbox{\hyperlink{classContinuous}{Continuous}} \\*The assignment template is used to create assignments in verilog }{\pageref{classContinuous}}{}
\item\contentsline{section}{\mbox{\hyperlink{classDeclaration}{Declaration}} }{\pageref{classDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classDefaultItem}{Default\+Item}} }{\pageref{classDefaultItem}}{}
\item\contentsline{section}{\mbox{\hyperlink{classDestination}{Destination}} \\*Used to create destination objects which are pretty much just decorated output streams }{\pageref{classDestination}}{}
\item\contentsline{section}{\mbox{\hyperlink{classDiv}{Div}} \\*Can be used to divide two numbers }{\pageref{classDiv}}{}
\item\contentsline{section}{\mbox{\hyperlink{classEmptyExpression}{Empty\+Expression}} \\*The empty expression class is just used as a place holder this makes it easier for visitor objects since they will not have to check for null }{\pageref{classEmptyExpression}}{}
\item\contentsline{section}{\mbox{\hyperlink{classEmptyStatement}{Empty\+Statement}} \\*The statement abstract class is used to store statement objects on the ast tree }{\pageref{classEmptyStatement}}{}
\item\contentsline{section}{\mbox{\hyperlink{classError}{Error}} \\*Used to create error objects }{\pageref{classError}}{}
\item\contentsline{section}{\mbox{\hyperlink{classErrorLog}{Error\+Log}} \\*The error log class is used to create an error log object }{\pageref{classErrorLog}}{}
\item\contentsline{section}{\mbox{\hyperlink{classExpression}{Expression}} \\*The \mbox{\hyperlink{classExpression}{Expression}} is an Interface that can be used to represent Expressions }{\pageref{classExpression}}{}
\item\contentsline{section}{\mbox{\hyperlink{classExprItem}{Expr\+Item}} }{\pageref{classExprItem}}{}
\item\contentsline{section}{\mbox{\hyperlink{classFor}{For}} \\*The statement abstract class is used to store statement objects on the ast tree }{\pageref{classFor}}{}
\item\contentsline{section}{\mbox{\hyperlink{classForever}{Forever}} \\*The statement abstract class is used to store statement objects on the ast tree }{\pageref{classForever}}{}
\item\contentsline{section}{\mbox{\hyperlink{classFunctionCall}{Function\+Call}} \\*The function call interface is used to define the implementation for all function call ast nodes }{\pageref{classFunctionCall}}{}
\item\contentsline{section}{\mbox{\hyperlink{classIdentifier}{Identifier}} \\*The identifier class is used to for \mbox{\hyperlink{classIdentifier}{Identifier}} AST nodes }{\pageref{classIdentifier}}{}
\item\contentsline{section}{\mbox{\hyperlink{classIf}{If}} \\*The statement abstract class is used to store statement objects on the ast tree }{\pageref{classIf}}{}
\item\contentsline{section}{\mbox{\hyperlink{classIfElse}{If\+Else}} \\*The statement abstract class is used to store statement objects on the ast tree }{\pageref{classIfElse}}{}
\item\contentsline{section}{\mbox{\hyperlink{classIndex}{Index}} \\*The index class is used so simulate something similar to indexing an array }{\pageref{classIndex}}{}
\item\contentsline{section}{\mbox{\hyperlink{classInputRegScalarDeclaration}{Input\+Reg\+Scalar\+Declaration}} }{\pageref{classInputRegScalarDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classInputRegVectorDeclaration}{Input\+Reg\+Vector\+Declaration}} }{\pageref{classInputRegVectorDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classInputWireScalarDeclaration}{Input\+Wire\+Scalar\+Declaration}} }{\pageref{classInputWireScalarDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classInputWireVectorDeclaration}{Input\+Wire\+Vector\+Declaration}} }{\pageref{classInputWireVectorDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classInteger}{Integer}} }{\pageref{classInteger}}{}
\item\contentsline{section}{\mbox{\hyperlink{classIntegerDeclaration}{Integer\+Declaration}} }{\pageref{classIntegerDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classIntVal}{Int\+Val$<$ int\+\_\+type $>$}} }{\pageref{classIntVal}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLAnd}{LAnd}} }{\pageref{classLAnd}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLexer}{Lexer}} \\*Generates a \mbox{\hyperlink{classLexer}{Lexer}} capable of Tokenizing the Verilog language }{\pageref{classLexer}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLNeg}{LNeg}} \\*The \mbox{\hyperlink{classLNeg}{LNeg}} performs a logical negation on the node or ! }{\pageref{classLNeg}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLong}{Long}} }{\pageref{classLong}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLOr}{LOr}} }{\pageref{classLOr}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLShift}{LShift}} \\*The bitwise and class is used to perform bitwise and operation }{\pageref{classLShift}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLValue}{LValue}} }{\pageref{classLValue}}{}
\item\contentsline{section}{\mbox{\hyperlink{classMod}{Mod}} \\*The subtract class is used for modulo operations }{\pageref{classMod}}{}
\item\contentsline{section}{\mbox{\hyperlink{classModItem}{Mod\+Item}} }{\pageref{classModItem}}{}
\item\contentsline{section}{\mbox{\hyperlink{classMult}{Mult}} }{\pageref{classMult}}{}
\item\contentsline{section}{\mbox{\hyperlink{classNeg}{Neg}} }{\pageref{classNeg}}{}
\item\contentsline{section}{\mbox{\hyperlink{classNonBlocking}{Non\+Blocking}} \\*The assignment template is used to create assignments in verilog }{\pageref{classNonBlocking}}{}
\item\contentsline{section}{\mbox{\hyperlink{classNumber}{Number$<$ num\+\_\+type $>$}} }{\pageref{classNumber}}{}
\item\contentsline{section}{\mbox{\hyperlink{classObjBase}{Obj\+Base}} }{\pageref{classObjBase}}{}
\item\contentsline{section}{\mbox{\hyperlink{classObject}{Object$<$ val\+\_\+type $>$}} }{\pageref{classObject}}{}
\item\contentsline{section}{\mbox{\hyperlink{classOutputRegScalarDeclaration}{Output\+Reg\+Scalar\+Declaration}} }{\pageref{classOutputRegScalarDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classOutputRegVectorDeclaration}{Output\+Reg\+Vector\+Declaration}} }{\pageref{classOutputRegVectorDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classOutputWireScalarDeclaration}{Output\+Wire\+Scalar\+Declaration}} }{\pageref{classOutputWireScalarDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classOutputWireVectorDeclaration}{Output\+Wire\+Vector\+Declaration}} }{\pageref{classOutputWireVectorDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classPosition}{Position}} }{\pageref{classPosition}}{}
\item\contentsline{section}{\mbox{\hyperlink{classReal}{Real}} }{\pageref{classReal}}{}
\item\contentsline{section}{\mbox{\hyperlink{classRealDeclaration}{Real\+Declaration}} }{\pageref{classRealDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classRegDeclaration}{Reg\+Declaration}} }{\pageref{classRegDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classRegScalarDeclaration}{Reg\+Scalar\+Declaration}} }{\pageref{classRegScalarDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classRegValue}{Reg\+Value}} }{\pageref{classRegValue}}{}
\item\contentsline{section}{\mbox{\hyperlink{classRegVectorDeclaration}{Reg\+Vector\+Declaration}} }{\pageref{classRegVectorDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classRepeat}{Repeat}} \\*The statement abstract class is used to store statement objects on the ast tree }{\pageref{classRepeat}}{}
\item\contentsline{section}{\mbox{\hyperlink{classReplication}{Replication}} \\*\mbox{\hyperlink{classFor}{For}} ast nodes representing verilogs replication operator }{\pageref{classReplication}}{}
\item\contentsline{section}{\mbox{\hyperlink{classRShift}{RShift}} \\*The bitwise and class is used to perform bitwise and operation }{\pageref{classRShift}}{}
\item\contentsline{section}{\mbox{\hyperlink{classScalarDeclaration}{Scalar\+Declaration}} }{\pageref{classScalarDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classSequentialBlock}{Sequential\+Block}} \\*The statement abstract class is used to store statement objects on the ast tree }{\pageref{classSequentialBlock}}{}
\item\contentsline{section}{\mbox{\hyperlink{classShort}{Short}} }{\pageref{classShort}}{}
\item\contentsline{section}{\mbox{\hyperlink{classSlice}{Slice}} }{\pageref{classSlice}}{}
\item\contentsline{section}{\mbox{\hyperlink{classSource}{Source}} \\*The source class is used to collect input from various input streams }{\pageref{classSource}}{}
\item\contentsline{section}{\mbox{\hyperlink{classStatement}{Statement}} \\*The statement abstract class is used to store statement objects on the ast tree }{\pageref{classStatement}}{}
\item\contentsline{section}{\mbox{\hyperlink{classString}{String}} \\*The string ast node class is used to store string objects }{\pageref{classString}}{}
\item\contentsline{section}{\mbox{\hyperlink{classSub}{Sub}} \\*The subtract class is used for subtract operations }{\pageref{classSub}}{}
\item\contentsline{section}{\mbox{\hyperlink{classSystemFunctionCall}{System\+Function\+Call}} \\*The system function call is used to create a system function or a function that starts with \$ }{\pageref{classSystemFunctionCall}}{}
\item\contentsline{section}{\mbox{\hyperlink{classSystemTaskCall}{System\+Task\+Call}} \\*The system function call is used to create a system function or a function that starts with \$ }{\pageref{classSystemTaskCall}}{}
\item\contentsline{section}{\mbox{\hyperlink{classTaskCall}{Task\+Call}} \\*The function call interface is used to define the implementation for all function call ast nodes }{\pageref{classTaskCall}}{}
\item\contentsline{section}{\mbox{\hyperlink{classTernaryOperation}{Ternary\+Operation}} }{\pageref{classTernaryOperation}}{}
\item\contentsline{section}{\mbox{\hyperlink{structTokDecl}{Tok\+Decl}} }{\pageref{structTokDecl}}{}
\item\contentsline{section}{\mbox{\hyperlink{classToken}{Token}} }{\pageref{classToken}}{}
\item\contentsline{section}{\mbox{\hyperlink{classUnary}{Unary}} \\*The unary super class defines unary operations }{\pageref{classUnary}}{}
\item\contentsline{section}{\mbox{\hyperlink{classUnsignedByte}{Unsigned\+Byte}} }{\pageref{classUnsignedByte}}{}
\item\contentsline{section}{\mbox{\hyperlink{classUnsignedInteger}{Unsigned\+Integer}} }{\pageref{classUnsignedInteger}}{}
\item\contentsline{section}{\mbox{\hyperlink{classUnsignedLong}{Unsigned\+Long}} }{\pageref{classUnsignedLong}}{}
\item\contentsline{section}{\mbox{\hyperlink{classUnsignedShort}{Unsigned\+Short}} }{\pageref{classUnsignedShort}}{}
\item\contentsline{section}{\mbox{\hyperlink{classVectorDeclaration}{Vector\+Declaration}} }{\pageref{classVectorDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classWait}{Wait}} \\*The statement abstract class is used to store statement objects on the ast tree }{\pageref{classWait}}{}
\item\contentsline{section}{\mbox{\hyperlink{classWhile}{While}} \\*The statement abstract class is used to store statement objects on the ast tree }{\pageref{classWhile}}{}
\item\contentsline{section}{\mbox{\hyperlink{classWireDeclaration}{Wire\+Declaration}} }{\pageref{classWireDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classWireScalarDeclaration}{Wire\+Scalar\+Declaration}} }{\pageref{classWireScalarDeclaration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classWireVectorDeclaration}{Wire\+Vector\+Declaration}} }{\pageref{classWireVectorDeclaration}}{}
\end{DoxyCompactList}
